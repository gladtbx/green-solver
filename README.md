# green-solver
Automatically exported from code.google.com/p/green-solver

This project is an extension of the GreenSolver, written by Willim Visser, Jaco Geldenhuys, Matthew Dwyer, and Juan Pablo Galeotti (No particular order).  I  extended their work in early 2014 to handle output generated by Klee.  By adding the command line option --use-query-log=solver:smt2, the constraints being sent to the STP solver that accompanies Klee can be captured.  These log files can then be inserted into this version of Green for analysis.

Originally the work was intended to see whether there were any opportunities for reducing the number of SMT calls required by Klee.  As such, I developed a parser for the SMT files generated by Klee, a factorizer for BV-logic, and a renamer.  The original BVFactorizer worked by first grouping all constraints that accessed the same element of an array (for example (arr[8]<arr[9]) would be grouped with (arr[8]<3).  In addition, whenever there was a constraint that symbolically accessed an array (for example arr[x]), then all other constraints that accessed that array, be they symbolically or concretely, would be grouped into the same factor as well.

As time went on, I began experimenting with more extreme ways to factorize an incoming constraint.  The theory was that the more pieces a constraint could be broken up into, the more likley the pieces would be cached, avoiding an SMT call completely.  I looked at ways to avoid the "collapse" caused by symbolic accesses.  For example, consider the constraints (arr[x]=2), (x<3), and (arr[4]<127).  Traditionally, because of the symbolic access, they would all be grouped into a single factor.  It is, however, possible to show that x could not possibly be 4 and therefore arr[x] could not possibly refer to arr[4].  Therefore, the constraint set can be broken down into 2 factors rather than the single factor that would normally be caused by a symbolic access.

This project contains various experiments at ways to break down factors coming out of Klee into smaller pieces.  (all are contained in za.ac.sun.cs.green.service.bvfactorizer.resources.UndeterminedArrayMerger) In the end, we determined that the computation necessary to prove that a symbolic access couldn't touch another access is too expensive to justify the slightly smaller pieces that we were able to split off.  Observationally, it seems that Klee generates one "main" constraint which can't be broken apart and is the main driver of SMT costs.  That's not to say it was all bad.  From this analysis we ended up finding several bugs in Klee, leading to a forthcoming paper.  Therefore, I am providing this code-base just in case someone else wants to try and dig into what's being spit out by Klee and to see if they can improve on it.

Finally, it should be noted that the renamer in its current form is unsafe.  I added the logic so it would both rename arrays to a canonical form as well as change the elements that are accessed.  Changing the elements that are accessed naively (as I've done) is unsafe because of the interplay between symbolic and concrete accesses.  For example, consider the constraints (arr[5]>3), (arr[x]<5), and (x=3).  Canonizing it the way I originally attempted creates the constraints (a[0]>3), (a[x]<5), and (x=3).  This is different from the original constraints.  It seems that the only correct way to rename the elements accessed is if, after factorization, all of the array accesses in a factor are concrete.  I kept the code in here just in case someone wants to build on the incorrect start that I made.

To Install:

1) Download Z3 for Java (https://leodemoura.github.io/blog/2012/12/10/z3-for-java.html)

2) Install according to the instructions on the website and add generated jar (com.microsoft.z3.jar) to the lib folder

3) Add headers for Z3 to environment (export DYLD_LIBRARY_PATH=/path/to/z3/bin)

4) run using command (java -cp path/to/green/bin:path/to/green/lib:path/to/green/lib* za.ac.sun.cs.green.parser.klee.TestFrontEnd path/to/klee.properties path/to/smt/query/log)

I suggest the following klee.properties file

```
## This creates a single redis store that will cache all of the queries
green.store = za.ac.sun.cs.green.store.redis.RedisStore

## This sets up the configuration for a request for "sat" and "non_recursive".  
##   - sat : In this case, the constraint will first be factorized, then the 
##           cache will be checked, and then, if the cache misses, the solver
##           will be invoked
##   - non_recursive : This request is used by parts of the factorizer to try
##                     and prove that two accesses to an array are independent.
##                     For example, a traditional SMT solver would combine
##                     {arr[x]> 8 && x < 5} and {arr[7] < 6} into a single factor
##                     due to the symbolic reference to array arr. The solver 
##                     is used to show that x != 7, and therefore the two can 
##                     remain independent.
green.services = sat, non_recursive

green.service.sat = (factorizer (z3))
green.service.sat.factorizer = za.ac.sun.cs.green.service.bvfactorizer.SATBVFactorizerService
green.service.sat.z3 = za.ac.sun.cs.green.service.z3.SATZ3NativeService

green.service.non_recursive = (z3)
green.service.non_recursive.z3 = za.ac.sun.cs.green.service.z3.SATZ3NativeService

## This option is for how to handle a symbolic access to an array.  The options are:
##   1) no -> use traditional bv factorization technique where any symbolic access to an array causes
##      all constraints that access that array to be grouped into a single factor.
##   2) smash_and_merge_necessary -> For every pair of factors that would traditionally be collapsed,
##      check to see whether the symbolic accesses in one factor could be equal to the accesses in
##      the other factor.
##   3) smash_dont_merge_experimental -> Don't merge factors that have symbolic acceseses at all. This
##      is dangerous because UNSAT ones could be called SAT.
smash_factors = smash_and_merge_necessary

## This options is for how to handle factors all symbolic accesses into a single factor or whether
## to try and split them.  For example, given two different factors, one of which contains arr[x]
## and the other of which contains arr[x+1], "merge" would immediately just stick them into the same
## factor which no_merge would use the SMT solver to see if they can be separated.  Based on some
## initial measurements, it seems that two symbolic accesses of the same array will almost always
## end up in the same factor in the end.  Therefore, the default behavior is "merge"
##   1) merge -> merge all pairs of factors that contain symbolic accesses to the same array
##   2) no_merge -> check for each pair of factors that contain symbolic accesses whether the accesses
##      could ever be equal to each other.
merge_symbolic_accesses = merge
```

I'm open to any and all improvements, including suggestions on how to better document the install process.  Please just send them along.  The Green project as well as my additions use the GNU Lesser General Public License.
